package com.rudn;

// File: Main.java
// Краткий теоретический материал и задания по структуре языка Java,
// идентификаторам, ключевым словам, операторам, типам данных, BigInteger/BigDecimal,
// массивам, перечислениям и отличиям примитивных и ссылочных типов.

/*
========== 1. Идентификаторы и ключевые слова ==========
- Идентификатор (имя переменной, метода, класса) — последовательность символов,
  начинающаяся с буквы, знака подчеркивания '_' или '$', далее могут быть цифры.
  Не рекомендуется использовать '$' и начинать с '_'.
- Ключевые слова — зарезервированные слова языка (например,
  abstract, assert, boolean, break, byte, case, catch, class, const (зарезервировано),
  continue, default, do, double, else, enum, extends, final, finally, float, for,
  if, implements, import, instanceof, int, interface, long, native, new, package,
  private, protected, public, return, short, static, strictfp, super, switch,
  synchronized, this, throw, throws, transient, try, void, volatile, while).

========== 2. Операторы ==========
- Присваивание: =
- Сравнения (отношения): ==, !=, <, >, <=, >=
  - Важно: для примитивных типов == сравнивает значения. Для ссылочных типов
    == сравнивает ссылки (т.е. указывают ли переменные на один объект).
    Для смыслового сравнения объектов обычно используют equals.
- Арифметические: +, -, *, /, % (остаток)
- Унарные: +, -, ++, --, !
- Логические: && (и, с кратк.), || (или, с кратк.), ! (не)
- Побитовые (для целых типов): &, |, ^ (исключающее или), ~ (инверсия), <<, >>, >>>
  - >>> — беззнаковый сдвиг вправо (для типов с знаком).
- Прочие: instanceof, ?: (тернарный оператор), + (конкатенация строк)

========== 3. Примитивные типы данных (Java) ==========
- byte  (8 бит, целое)
- short (16 бит, целое)
- int   (32 бит, целое) — чаще всего используемый для целых
- long  (64 бит, целое) — литералы с суффиксом L
- float (32 бит, с плавающей точкой) — литералы с суффиксом f
- double(64 бит, с плавающей точкой) — по умолчанию для дробных чисел
- char  (16 бит, UTF-16 кодовая единица)
- boolean (true/false)

Обратите внимание на переполнение целочисленных типов и особенности
сравнения дробных чисел (погрешность представления).

========== 4. BigInteger и BigDecimal ==========
- BigInteger — класс для целых чисел произвольной точности (java.math.BigInteger).
  Примеры: операции add, subtract, multiply, divide, pow, mod, gcd.
  Нельзя использовать обычные операторы + - * /, нужно вызывать методы.
- BigDecimal — класс для десятичных чисел с произвольной точностью (java.math.BigDecimal).
  Используется для финансовых вычислений, где важна точность и контроль округления.
  Методы: add, subtract, multiply, divide, setScale(..., RoundingMode).
- Создавать new BigDecimal(double) — не рекомендуется (может ввести погрешности);
  лучше использовать new BigDecimal(String) или BigDecimal.valueOf(long)/valueOf(double).

Пример использования (набросок):
  BigInteger a = new BigInteger("12345678901234567890");
  BigInteger b = a.multiply(a);
  BigDecimal x = new BigDecimal("0.1");
  BigDecimal y = x.add(new BigDecimal("0.2")); // точно 0.3

========== 5. Ссылочные типы: массивы и перечисления ==========
- Массивы: int[] arr = new int[10]; или String[] names = {"A","B"};
  Массивы — объекты, хранят ссылку; arr.length — длина.
- Перечисления (enum): удобны для набора именованных констант.
  Пример:
    enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }
  Enum может иметь поля, конструктор и методы.

========== 6. Принципиальные различия между примитивными и ссылочными типами ==========
- Примитивные типы хранят сами значения; ссылочные типы — ссылки на объекты.
- Размер/представление: примитивы имеют фиксированный размер, объекты — динамически.
- Значение по умолчанию: поля примитивных типов имеют значения (0, false, 'u0000'),
  ссылочные поля — null.
- Присваивание: при присваивании примитив копируется (копия значения);
  при присваивании ссылочного — копируется ссылка (оба указывают на один объект).
- Сравнение: для примитивов используйте ==; для объектов — чаще equals.
- Передача в методы: всегда "передача по значению". Для объектов копируется ссылка
  (поэтому внутри метода можно изменить состояние объекта, но нельзя переназначить
  ссылку вызывающей стороне).
*/

public class Main {

    public static void main(String[] args) {
        System.out.println("Задания для студентов: реализуйте помеченные места (// TODO).");
        System.out.println("Откройте этот файл и следуйте комментариям внутри класса.");

        /*
         * Ниже перечислены задания. Реализуйте их в соответствующих методах/блоках.
         * Для каждого задания даны подсказки и ожидаемый результат.
         *
         * 1) Идентификаторы, ключевые слова, операторы
         *    - Создайте переменные разных примитивных типов, используйте арифметику,
         *      сравнения и логические операции. Проверьте пред- и пост-инкремент.
         *
         * 2) Арифметические и побитовые операции
         *    - Реализуйте методы, которые показывают отличие >> и >>>, а также примеры & | ^ ~.
         *
         * 3) Примитивные типы и обёртки, сравнение
         *    - Покажите поведение == и equals для Integer, String и примитивов.
         *
         * 4) Массивы и enum
         *    - Создайте массив имен (String[]), заполните его, отсортируйте (можно вручную)
         *      и выведите. Создайте enum для дней недели и используйте его в switch.
         *
         * 5) BigInteger
         *    - Реализуйте метод bigIntegerFactorial(int n) который возвращает факториал n
         *      в виде BigInteger. Проверьте для n = 20, 50, 100.
         *
         * 6) BigDecimal
         *    - Реализуйте вычисление итоговой суммы с процентом: пример финансовой задачи,
         *      где важно точное округление. Используйте BigDecimal и RoundingMode.
         *
         * 7) Примитивы vs ссылки: передача в метод
         *    - Напишите пример: метод пытаетcя изменить примитив и объект (например, массив или
         *      собственный класс с полем). Покажите результаты до/после вызова.
         *
         * Реализация должна быть внизу файла (см. заглушки методов). Не забудьте
         * добавить комментарии/объяснения к тому, что вы наблюдаете.
         */
    }

    // -------------------------
    // Задание 1: примитивы и операторы
    // -------------------------
    // TODO: реализуйте метод, демонстрирующий работу арифметических, логических и сравнительных операторов.
    // Подсказка: создайте несколько переменных (int, double, boolean), выполните операции и распечатайте результаты.
    public static void demoPrimitivesAndOperators() {
        // TODO: ваша реализация
    }

    // -------------------------
    // Задание 2: побитовые операции и сдвиги
    // -------------------------
    // TODO: реализуйте метод, показывающий разницу между >> и >>> и примеры побитовых &, |, ^, ~
    public static void demoBitwiseOperations() {
        // TODO: ваша реализация
    }

    // -------------------------
    // Задание 3: примитивы vs обёртки и сравнения
    // -------------------------
    // TODO: реализуйте сравнения с использованием == и equals для Integer и String.
    // Покажите поведение кеширования Integer (значения в диапазоне -128..127) и отличия за его пределами.
    public static void demoWrappersAndEquality() {
        // TODO: ваша реализация
    }

    // -------------------------
    // Задание 4: массивы и enum
    // -------------------------
    // TODO: создайте массив строк, отсортируйте и выведите.
    // Создайте enum Day { ... } и используйте его в switch (пример печати "Working day" / "Weekend").
    public static void demoArraysAndEnum() {
        // TODO: ваша реализация
    }

    // -------------------------
    // Задание 5: BigInteger — факториал
    // -------------------------
    // TODO: реализуйте факториал n (n >= 0) с помощью BigInteger.
    // Подсказка: используйте java.math.BigInteger, метод multiply, цикл или рекурсию.
    public static java.math.BigInteger bigIntegerFactorial(int n) {
        // TODO: ваша реализация
        return java.math.BigInteger.ONE;
    }

    // -------------------------
    // Задание 6: BigDecimal — финансовая задача
    // -------------------------
    // TODO: реализуйте метод calculateFinalAmount:
    // параметры: principal (String), annualRatePercent (String), years (int)
    // возвращает BigDecimal с суммой через years лет при годовой капитализации.
    // Используйте scale 2 и RoundingMode.HALF_UP для финального результата.
    //
    // Формула: final = principal * (1 + rate/100)^years
    public static java.math.BigDecimal calculateFinalAmount(String principal,
                                                            String annualRatePercent,
                                                            int years) {
        // TODO: ваша реализация
        return java.math.BigDecimal.ZERO;
    }

    // -------------------------
    // Задание 7: передача примитивов и ссылок в метод
    // -------------------------
    // TODO: продемонстрируйте, что примитивы передаются по значению, а ссылка — копируется.
    // Напишите метод tryToModify(int x, int[] arr, MyHolder holder) и покажите эффекты.
    static class MyHolder {
        public int value;

        public MyHolder(int v) {
            value = v;
        }
    }

    public static void tryToModify(int x, int[] arr, MyHolder holder) {
        // TODO: ваша реализация
        // Пример идей:
        // x = x + 10;
        // if (arr != null && arr.length > 0) arr[0] = arr[0] + 10;
        // if (holder != null) holder.value = holder.value + 10;
    }

    // -------------------------
    // Дополнительные подсказки / примеры использования BigInteger / BigDecimal
    // -------------------------
    /*
    Примеры (вспомогательно, не вызываются автоматически):

    // BigInteger:
    BigInteger a = new BigInteger("12345678901234567890");
    BigInteger b = BigInteger.valueOf(42);
    BigInteger c = a.multiply(b).add(BigInteger.ONE);

    // BigDecimal:
    BigDecimal p = new BigDecimal("1000.00");
    BigDecimal rate = new BigDecimal("2.5"); // 2.5%
    BigDecimal factor = BigDecimal.ONE.add(rate.divide(new BigDecimal("100")));
    BigDecimal result = p.multiply(factor.pow(5)).setScale(2, java.math.RoundingMode.HALF_UP);

    // Проверка игнорирования ошибок округления: избегайте new BigDecimal(0.1)
    BigDecimal bad = new BigDecimal(0.1); // содержит двоичную погрешность
    BigDecimal good = new BigDecimal("0.1"); // точно 0.1
    */

    // Конец файла — добавляйте свои реализации выше.
}
